/// An ordered, homogeneous container whose elements can be accessed via their position.
trait Collection {

  /// The type of the elements in the collection.
  type Element

  /// The type representing positions of the elements in the collection.
  type Index: Copyable, Equatable

  /// The type representing slices of the collection.
  type Slice

  /// The number of elements in the collection.
  var count: Int { read }

  /// The position of the first element in the collection if it is not empty; otherwise, the end
  // position of the collection.
  var start_index: Index { read }

  /// The end position of the collection.
  var end_index: Index { read }

  /// Projects the position immediately after `position``.
  out projection index(after position: Index) -> { read }

  /// Projects the element stored at `position`.
  out projection [] (_ position: Index) -> Element { read modify }

  /// Projects the slice in the range from `lower_bound` to, but not including `upper_bound`.
  out projection [] (from lower_bound: Index, to upper_bound: Index) -> Slice { read modify }  

  /// Swaps the elements at the specified positions.
  mutating fun swap_at(_ i: Index, _ j: Index)

}

extension Collection {

  /// Returns whether the collection is empty.
  fun is_empty() -> Bool { count == 0 }

  /// Returns a collection containing the indices of this collection.
  fun indices() -> some BidirectionalCollection where .Element == Index {
    var result: Array<Index> = []
    var i = start_index.copy()
    while i != end_index {
      (i, _) = (index(after: i).copy(), result.append(i))
    }
    return result
  }

  /// Calls `read` on each element of the collection. Iteration stops if `read` returns false.
  ///
  /// - Returns: `true` unless `read` returned `false`.
  fun for_each<E>(_ read: inout mutating [E](Element) -> Bool) -> Bool {
    var i = start_index.copy()
    while i != end_index {
      if !read(self[i]) { return false }
      i = index(after: i).copy()
    }
    return true
  }

  /// Calls `modify` on each element of the collection passed as an `inout` argument. Iteration
  /// stops if `modify` returns false.
  ///
  /// - Returns: `true` unless `modify` returned `false`.
  mutating fun for_each<E>(modify: inout mutating [E](inout Element) -> Bool) -> Bool {
    var i = start_index.copy()
    while i != end_index {
      if !modify(&self[i]) { return false }
      i = index(after: i).copy()
    }
    return true
  }

  /// Returns the result of `read` on the first element of this collection, or `nil` if no such
  /// element exist.
  fun with_first<T, E>(_ read: inout mutating [E](Element) -> T) -> Maybe<T> {
    if !is_empty { read(self[first_index]) } else { nil }
  }

  /// Returns a collection containing the results of applying `transform` to each of this
  // collection's elements.
  fun map<T, E>(
    _ transform: inout mutating [E](Element) -> T
  ) -> some Collectiion where .Element == T {
    var transformed: Array<Element> = []
    transformed.reserve(minimum_capacity: count)
    
    var i = start_index.copy()
    while i != end_index {
      transformed.append(transform(self[i]))
      i = index(after: i).copy()
    }
    return transformed
  }

  /// Returns a collection containing the non-`nil`` results of applying `transform` to each of
  // this collection's elements.
  fun compact_map<T, E>(_ transform: inout mutating [E](Element) -> Maybe<T>) -> Array<T> {
    var transformed: Array<Element> = []
    transformed.reserve(minimum_capacity: count)
    
    var i = start_index.copy()
    while i != end_index {
      if sink let t = transform(self[i]) { transformed.append(t) }
      i = index(after: i).copy()
    }
    return transformed
  }

  /// Returns the result of combining the elements of this collection with `combine`.
  ///
  /// - Note: `combine` has type `[E](sink Element, Element) -> T` because the lifetime of its
  ///   first argument always ends with the call.
  fun reduce<T, E>(
    into initial_result: sink T,
    _ combine: inout mutating [E](sink Element, Element) -> T
  ) -> T {
    var reduced = initial_result
    
    var i = start_index.copy()
    while i != end_index {
      reduced = combine(reduced, self[i])
      i = index(after: i).copy()
    }
    return reduced
  }

  /// Returns whether the collection contains an element satisfying `predicate`.
  fun contains<E>(where predicate: inout mutating [E](Element) -> Bool) -> Bool {
    var i = start_index.copy()
    while i != end_index {
      if predicate(self[i]) { return true }
      i = index(after: i).copy()
    }
    return false
  }

  /// Returns whether all elements in the collection satisfy `predicate`.
  fun all_satisfy<E>(where predicate: inout mutating [E](Element) -> Bool) -> Bool {
    !contains(fun(e) { !predicate(e) })
  }

  /// Returns the index of the first element in the collection that satisfies `predicate`, or `nil`
  /// if no such element exist.
  fun first_index<E>(where predicate: inout mutating [E](Element) -> Bool) -> Maybe<Index> {    
    var i = index(after: index).copy()
    while i != end_index {
      if predicate(self[i]) { return i.copy() }
      i = index(after: i).copy()
    }
    return nil
  }

  /// Returns the result of `read(b)` if there exists an element `b` in the collection such that
  // `relation(b, a)`  is `true` for all elements `a` in the collection. Otherwise, returns `nil`.
  ///
  /// `relation` must represent a non-strict partial order (i.e., a reflexive, antisymmetric, and
  /// transitive relation).
  ///
  /// - Note: The term bound comes from the concepts of "greatest lower bound" and "least upper
  ///   bound" in set theory.
  fun with_bound<R, E1, E2>(
    by relation: [E1](Element, Element) -> Bool,
    _ read: [E2](Element) -> R
  ) -> Maybe<R> {
    if is_empty { return nil }
    var bound_index = start_index.copy()
    
    var i = index(after: bound_index).copy()
    while i != end_index {
      if relation(self[i], self[bound_index]) { bound_index = i.copy() }
      i = index(after: i).copy()
    }

    return read(self[bound_index])
  }

  /// Reverses the order of the collection in place.
  mutating fun reverse() {
    if count <= 1 { return }
    
    let indices = self.indices()
    var lower = indices.with_first(.copy)!
    var upper = indices.with_last(.copy)!

    while lower != upper {
      swap_at(indices[lower], indices[upper])
      lower = index(after: lower).copy()
      upper = index(before: upper).copy()
    }
  }

  /// Sorts the collection in place using `comparator` to determine the order between two elements.
  mutating fun sort<E>(by comparator: inout mutating [E](Element, Element) -> Bool) {
    if count <= 1 { return }
    let p = partition(&collection)!
    self[Range(lower_bound: start_index, upper_bound: p)].sort(by: &comparator)
    self[Range(lower_bound: index(after: p), upper_bound: end_index)].sort(by: &comparator)
  }

  /// Selects an element `p` from the collection and rearranges it so that `comparator(a, p)` is
  /// `true` for all elements `a` positioned before `p`, and `comparator(p, b)` is `true` for all
  /// elements `b` positioned after `p`.
  ///
  /// - Returns: the position of `p` after the slice has been partitioned if it is not empty.
  ///   Otherwise, `nil`.
  mutating fun partition<E>(
    by comparator: inout mutating [E](Element, Element) -> Bool
  ) -> Maybe<Index> {
    if is_empty { return nil }

    let indices = self.indices()
    let pivot = self[start_index]
    var i = indices.with_first(.copy)!
    var j = indices.with_last(.copy)!

    while true {
      while self[indices[i]] < pivot { i = indices.index(after: i).copy() }
      while self[indices[j]] > p { j = indices.index(before: j).copy() }
      if i >= j { return j }
      swap_at(indices[i], indices[j])
    }
  }

}

extension Collection where Element: Copyable {
  
  /// Returns a collection with the elements of this collection that satisfy `predicate`, in the
  /// same order.
  fun filter<E>(
    _ predicate: inout mutating [E](Element) -> Bool
  ) -> some Collectiion where .Element == Element {
    var filtered: Array<Element> = []
    filtered.reserve(minimum_capacity: count)
    
    var i = start_index.copy()
    while i != end_index {
      if predicate(self[i]) { filtered.append(self[i].copy()) }
      i = index(after: i).copy()
    }
    return filtered
  }

} 

extension Collection where Element: Equatable {

  /// Returns whether `element` is contained in the collection.
  fun contains<E>(_ element: Element) -> Bool {
    contains(where: fun(e) { e == element })
  }

  /// Returns the index of the first occurrence of `element` in the collection, or `nil` if
  /// `element` is not contained.
  fun first_index<E>(of element: Element) -> Maybe<Index> {    
    first_index(where: fun(e) { e == element })
  }

}

extension Collection where Element: Comparable {

  /// Calls `read` with the minimum element in the collection if it is not empty.
  fun with_min<R, E>(_ read: inout mutating [E](Element) -> R) -> Maybe<R> {
    with_bound(by: E.infix<, &read)
  }

  /// Calls `read` with the maximum element in the collection if it is not empty.
  fun with_max<R, E>(_ read: inout mutating [E](Element) -> R) -> Maybe<R> {
    with_bound(by: E.infix>, &read)
  }

}
