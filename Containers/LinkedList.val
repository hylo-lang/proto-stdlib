/// A list of homogeneous elements stored as a chain of nodes.
type LinkedList<Element> = Node | Empty

extension LinkedList {
  
  type Node = (head: Element, tail: indirect Self)
  
  type Empty = Unit

}

extension LinkedList {

  /// Indicates whether the list is empty.
  ///
  /// - Complexity: O(1)
  var is_empty: Bool {
    read { yield self is Empty }
  }

  /// The number of elements in the list.
  ///
  /// - Complexity: O(n)
  var count: Int {
    read {
      match self {
        () { yield 0 }
        let (head: _, tail: tail) { yield 1 + tail.count }
      }
    }
  }

  /// Returns the result of `read` on the first element of this list, or `nil` if no such
  /// element exist.
  ///
  /// - Complexity: O(1)
  fun with_first<T, E>(_ read: inout mutating [E](Element) -> T) -> Maybe<T> {
    match self {
      () { nil }
      let (head: head, tail: _) { read(head) }
    }
  }

  /// Calls `read` on each element of the collection. Iteration stops if `read` returns false.
  ///
  /// - Returns: `true` unless `read` returned `false`.
  /// - Complexity: O(1)
  fun for_each<E>(_ read: inout mutating [E](Element) -> Bool) -> Bool {
    match self {
      (): { return true }
      let (head: head, tail: tail) {
        if !read(head) { return false }
        return tail.for_each(&read)
      }
    }
    return true
  }

  /// Calls `modify` on each element of the list passed as an `inout` argument. Iteration stops if
  /// if `modify` returns false.
  ///
  /// - Returns: `true` unless `modify` returned `false`.
  mutating fun for_each<E>(modify: inout mutating [E](inout Element) -> Bool) -> Bool {
    match self {
      (): { return true }
      inout (head: head, tail: tail) {
        if !read(&head) { return false }
        return tail.for_each(modify: &read)
      }
    }
    return true
  }

  /// - Complexity: O(1)
  mutating fun prepend(_ element: Element) {
    self = (head: element, tail: self)
  }

  /// - Complexity: O(n)
  mutating fun append(_ element: Element) {
    match self {
      inout empty: Empty { empty = (head: element, tail: ()) }
      inout (head: _, tail: tail) { tail.append(element) }
    }
  }

  /// - Complexity: O(n)
  mutating fun reverse() {
    self = _reverse(into: ())
  }

  /// A helper function to implement `reverse`.
  consuming fun reverse(into front: Self) -> Self {
    match back {
        () { return front }
        sink let (head: head, tail: tail) {
          tail._reverse(into: (head: head, tail: front))
        }
      }
  }

  /// Consumes this list and returns a new list with the elements that satisfy `predicate`, in the
  /// same order.
  ///
  /// - Complexity: O(n)
  consuming fun filter<E>(_ predicate: inout mutating [E](Element) -> Bool) -> Self {
    match self {
      sink let empty: Empty { empty }
      sink let (head: head, tail: tail) {
        if predicate(head) {
          (head: head, tail: tail.filter(&predicate))
        } else {
          tail.filter(&predicate)
        }
      }
    }
  }

  /// Consumes this list and returns a new list with the result of applying `transform` to each
  /// element.
  ///
  /// - Complexity: O(n)
  consuming fun map<T, E>(_ transform: inout mutating [E](Element) -> T) -> Self {
    match self {
      sink let empty: Empty { empty }
      sink let (head: head, tail: tail) {
        (head: transform(head), tail: tail.map(&transform))
      }
    }
  }

  /// Consumes this list and returns the result of combining its elements with `combine`.
  ///
  /// - Complexity: O(n)
  consuming fun reduce<T, E>(
    into initial_result: sink T,
    _ combine: inout mutating [E](sink Element, sink Element) -> T
  ) -> T {
    match self {
      () { initial_result }
      sink let (head: head, tail: tail) {
        tail.reduce(into: combine(initial_result, head), &combine)
      }
    }
  }

  /// Returns whether the list contains an element satisfying `predicate`.
  ///
  /// - Complexity: O(n)
  fun contains<E>(where predicate: inout mutating [E](Element) -> Bool) -> Bool {
    match self {
      () { false }
      let (head: head, tail: tail) {
        if predicate(head) { true } else { tail.predicate(&predicate) }
      }
    }
  }

  /// Returns whether all elements in the list satisfy `predicate`.
  ///
  /// - Complexity: O(n)
  fun all_satisfy<E>(where predicate: inout mutating [E](Element) -> Bool) -> Bool {
    !contains(fun(e) { !predicate(e) })
  }

  /// Returns the result of `read(b)` if there exists an element `b` in the collection such that
  // `relation(b, a)`  is `true` for all elements `a` in the collection. Otherwise, returns `nil`.
  ///
  /// `relation` must represent a non-strict partial order (i.e., a reflexive, antisymmetric, and
  /// transitive relation).
  ///
  /// - Note: The term bound comes from the concepts of "greatest lower bound" and "least upper
  ///   bound" in set theory.
  ///
  /// - Complexity: O(n)
  fun with_bound<R, E1, E2>(
    by relation: [E1](Element, Element) -> Bool,
    _ read: [E2](Element) -> R
  ) -> Maybe<R> {
    match self {
      () { nil }
      let (head: head, tail: tail) {
        tail._with_bound(head, by: &relation, &read)
      }
    }
  }

  /// A helper function to implement `with_bound`.
  fun _with_bound<R, E1, E2>(
    _ bound: Element,
    by relation: [E1](Element, Element) -> Bool,
    _ read: [E2](Element) -> R
  ) -> R {
    match self {
      () { read(bound) }
      let (head: head, tail: tail) {
        if relation(head, bound) {
          tail._with_bound(head, by: &relation, &read)
        } else {
          tail._with_bound(bound, by: &relation, &read)
        }
      }
    }
  }

  /// Sorts the list using `comparator` to determine the order between two elements.
  ///
  /// - Complexity: O(n * log n)
  mutating fun sort<E>(by comparator: inout mutating [E](Element, Element) -> Bool) {
    /// Merges two sorted lists.
    fun _merge[inout comparator](_ l: sink Self, _ r: sink Self) -> Self {
      match l {
        // l is empty.
        () {return r }
        
        // r is empty.
        sink let l where r == () { return l }
        
        // l and r are not empty.
        sink let (head: lh, tail: lt) {
          let (head: rh, tail: rb) = r as! Node<Element>
          if comparator(lh, rh) {
            return (head: lh, tail: _merge(lt, (head: rh, tail: rt)))
          } else {
            return (head: rh, tail: _merge((head: lh, tail: lt), rt))
          }
        }
      }
    }

    // Nothing to do if the lenght of the list is 0 or 1.
    match self {
      () { return }
      let (head: _, tail: ()) { return }
      _ {}
    }

    // Divide and conquer.
    var (first, second) = split()
    first.sort()
    second.sort()

    // Merge.
    self = _merge(first, second)
  }

  /// Splits the list into two sub-lists of equal length.
  ///
  /// If the list has an odd number of elements, the first sub-list gets the extra element.
  ///
  /// - Complexity: O(n)
  consuming fun split() -> (Self, Self) {
    let second = _split(index: 1).second
    return (self, second)
  }

  mutating fun _split(index: Int) -> (half_point: Int, second: Self) {
    match self {
      () { return (half_point: index / 2, second: ()) }
      inout var (head: head, tail: tail) {
        let (half_point, second) = tail._split(index: index + 1)
        if index == half_point {
          self = ()
          return (half_point: half_point, second: (head: head, tail: tail))
        } else {
          return (half_point: half_point, second: second)
        }
      }
    }
  }

}

extension LinkedList: Copyable where Element: Copyable {}

extension LinkedList: Equatable where Element: Equatable {

  /// Returns whether `element` is contained in the collection.
  ///
  /// - Complexity: O(n)
  fun contains<E>(_ element: Element) -> Bool {
    contains(where: fun(e) { e == element })
  }

}

extension LinkedList: Hashable where Element: Hashable {}

extension LinkedList where Element: Comparable {

  /// Calls `read` with the minimum element in the collection if it is not empty.
  ///
  /// - Complexity: O(n)
  fun with_min<R, E>(_ read: [E](Element) -> R) -> Maybe<R> {
    with_bound(by: E.infix<, read)
  }

  /// Calls `read` with the maximum element in the collection if it is not empty.
  ///
  /// - Complexity: O(n)
  fun with_max<R, E>(_ read: [E](Element) -> R) -> Maybe<R> {
    with_bound(by: E.infix>, read)
  }

}