/// DESIGN NOTES:
/// - I considered defining a consuming variant of `for_each(_:)` but it is a bit unclear how one
///    can implement it safely. It'd be best if 'Container' is easy to implement.
/// - I picked that `with_some(where:)` rather than `with_first(where:)` to avoid suggesting any
///   order. I also considered `with_random_element(where:)`.
/// - I didn't find a way to define `with_some(where:)` as projections. I can't yield because I
///   iterate over elements in a closure. 'Collection' solves this problem using indices.
/// - I'm not sure there's a way to implement `min(by:)`, `max(by:)` and `filter` without indices.

/// An unordered and unbounded container of homogeneous elements.
///
/// Conforming types must provide an implementation of `for_each(_:)`. All other requirements have
/// a default implementation.
trait Container {

  /// The type of the contained elements.
  type Element

  /// Indicates whether the container is empty.
  let is_empty: Bool

  /// A value less than or equal to the number of elements in the container.
  let underestimated_count: Int

  /// Calls `action` on each contained element.
  fun for_each<E>(_ action: [E](Element) -> LoopAction)

  /// Returns whether there exists a contained element satisfying `predicate`.
  fun contains(where predicate: (Element) -> Bool) -> Bool

  /// Returns whether all contained elements satisfy `predicate`.
  fun all_satisfy(_ predicate: (Element) -> Bool) -> Bool

  /// Returns a container with the results of mapping `transform` over this container's elements.
  fun map<E, Result>(
    _ transform: [E](Element) -> Result
  ) -> some Container where .Element == Result

  /// Calls `action` on some contained element satisfying `predicate`.
  ///
  /// The method does guarantee to call `action` with the same element when it is called repeatedly
  /// with the same predicate.
  fun with_some<R>(where predicate: (Element) -> Bool, _ action: (Element) -> R) -> Maybe<R>

}

// MARK: Default implementations
extension Container {

  var underestimated_count: Int {
    read { yield 0 }
  }

  fun contains(where predicate: (Element) -> Bool) -> Bool {
    var found = false
    for_each(fun[inout found](e) {
      if predicate(e) { found = true; return Break() }
    })
    return found
  }

  fun all_satisfy(_ predicate: (Element) -> Bool) -> Bool {
    var satisfied = true
    for_each(fun[inout satisfied](e) {
      if !predicate(e) { satisfied = false; return Break() }
    })
    return satisfied
  }

  fun map<E, Result>(
    _ transform: [E](Element) -> Result
  ) -> some Container where .Element == Result {
    var transformed: Array<Result> = []
    transformed.reserve_minimum_capacity(underestimated_count)

    for_each(fun[inout transformed](e) { transformed.append(transform(e)) })
    return transformed
  }

  fun with_some<R>(where predicate: (Element) -> Bool, _ action: (Element) -> R) -> Maybe<R> {
    var r: Maybe<R> = nil
    for_each(fun[inout found](e) {
      if predicate(e) { r = action(e); return Break() }
    })
    return r
  }

}

// MARK: Conditionally provided implementations

extension Container where Element: Equatable {

  /// Returns whether there exists a contained element equal to `element`.
  fun contains(_ element: Element) -> Bool {
    contains(where: element.infix==)
  }

}