// Questions:
// - Should `pops` be a requirement of `Collection`?
// - Should we have a `CopyableCollection` trait to require `copies`?

// # Helpers

// The header of an array.
typealias ArrayHeader = (count: Int, capacity: Int)

// The header of the empty array.
let empty_array_header: ArrayHeader = (count: 0, capacity: 0)

// # Primary declaration

// An array of homogeneous elements.
public type Array<Element> {

  // A generator that consumes an array to produce its elements.
  public type ConsumingGenerator: Generator {

    // Implementation note:
    // 
    // The generator moves the elements contained in the array starting from the front. The other
    // elements are never moved, instead the generator uses an index to point at the next element
    // to output. Consequently, the invariants of the array do not hold while the generator is
    // alive, which is responsible to restore them before the array is destroyed.

    // The array from which elements are being consumed.
    //
    // This property is `nil` when there are no more elements to output.
    var array: Maybe<Array>

    // The index of the next element to output.
    //
    // - Requires: `array == nil` or `next_element_index < array.count()`
    var next_element_index = 0

    // Creates a consuming generator that produces the elements in `array`.
    init(_ array: sink Array) {
      self.array = if array.is_empty() { nil } else { array }
    }

    drop() {
      inout array = array ?? { return }
      assert(next_element_index < array.count())

      // Manually drop the remainder of the array's elements.
      for let i in next_element_index ..< array.count() { array.buffer[i].drop() }

      // Deallocate the array's buffer and destroy it.
      array.base.deallocate()
      array.base = MutableRawPointer(pointer(to: ArrayHeader))
      array.drop()
    }

    public fun next() -> Maybe<Element> {
      inout {
        inout array = array ?? { return nil }
        
        defer {
          next_element_index += 1

          // If we reached the end of the array, deallocate it's buffer and destroy it.
          if next_element_index == array.count() {
            array.base.deallocate()
            array.base = MutableRawPointer(pointer(to: ArrayHeader))
            self.array = nil
          }
        }
        
        return array.buffer[next_element_index]
      }
    }

  }

  // A pointer to the array's storage.
  var base: MutableRawPointer

  // Creates an empty array.
  public init() {
    base = MutableRawPointer(pointer(to: ArrayHeader))
  }

  // Creates an empty array with a minimum capacity.
  public init(minimum_capacity: Int) {
    base = Memory.allocate(
      bytes: MemoryLayout<ArrayHeader>.size + minimum_capacity * MemoryLayout<Element>.stride,
      alignment: MemoryLayout<ArrayHeader>.alignment)
    header.initialize(to: (count: 0, capacity: minimum_capacity))
  }

  // Destroys the array.
  drop() {
    if header != MutablePointer(pointer(to: empty_array_header)) {
      for let i in 0 ..< header.unsafe_pointee.count { buffer[i].drop() }
      base.deallocate()
    }

    // Note: There's no need to drop `base` because it's trivially destructible.
  }

  // A pointer to the array's header.
  property header: MutablePointer<ArrayHeader> {
    base.assume_bound<ArrayHeader>()
  }

  // A pointer to the arrays's elements.
  property buffer: MutablePointer<Element> {
    base.advanced(MemoryLayout<ArrayHeader>.size).assume_bound<Element>()
  }

  // Returns whether the array is empty.
  public fun is_empty() -> Bool { header.unsafe_pointee.count == 0 }

  // Returns the number of elements in the array.
  public fun count() -> Int { header.unsafe_pointee.count }

  // Returns the capacity of the array, i.e., the number of elements the array can contain without
  // allocating new memory.
  public fun capacity() -> Int { header.unsafe_pointee.capacity }

  // Appends `element` to the array.
  public fun append(_ element: sink Element) {
    inout {
      if count() + 1 < capacity() { resize(minimum_capacity: may(1, capacity() * 2)) }
      buffer[count()] = element
      header.unsafe_pointee.count += 1
    }
  }

  // Appends the elements produced by `genetator` to the array.
  public fun append<G: Generator where G.Element == Element>(elements_of generator: inout G) {
    inout { while let e = generator.next() { append(e) } }
  }

  // Removes and returns the last element of the array, if any.
  public fun pop_last() -> Maybe<Element> {
    inout {
      if is_empty() { return nil }

      let i = count() - 1
      defer { header.unsafe_pointee.count = i }
      return buffer[i]
    }
  }

  // Resizes the array such that it can contain at least `minimum_capacity` elements without
  // allocating new memory.
  public fun resize(minimum_capacity: Int) {
    inout {
      if capacity() >= minimum_capacity { return }
      
      // Allocate new storage.
      let new_base = Memory.allocate(
        bytes: MemoryLayout<ArrayHeader>.size + minimum_capacity * MemoryLayout<Element>.stride,
        alignment: MemoryLayout<ArrayHeader>.alignment)

      // Configure the new storage's header and move the elements.
      new_base.assume_bound<ArrayHeader>()
        .initialize(to: (count: count(), capacity: minimum_capacity))
      new_base.advanced(MemoryLayout<ArrayHeader>.size).assume_bound<Element>()
        .move_initialize(from: buffer, count: count())

      // Reassign the array's storage.
      base.deallocate()
      base = new_base
    }
  }

}

// # Conditional API

extension Array where Element: Copyable {

  // A generator that produces the elements of an array by copying them.
  public type CopyingGenerator: Generator {

    // The array from which elements are being consumed.
    var array: let Array

    // The index of the next element to output.
    //
    // - Requires: `next_element_index <= array.count()`
    var next_element_index = 0

    public fun next() -> Maybe<Element> {
      inout {
        if next_element_index == array.count() { return nil }
        defer { next_element_index += 1 }
        return array.buffer[next_element_index].copy()
      }
    }

  }

  // Projects a generator that produces copies of the array's elements
  public property copies: var CopyingGenerator {
    let { CopyingGenerator(array: self) }
  }

  public fun append(_ element: sink Element) {
    let { copy().append(element) }
  }

  public fun append<G: Generator where G.Element == Element>(elements_of generator: inout G) {
    let { copy().append(&generator) }
  }

}

// # Conformances

public conformance Array: Sinkable where Element: Sinkable {}

public conformance Array: Copyable where Element: Copyable {

  public fun copy() -> Self {
    var other = Array(minimum_capacity: count())
    if is_empty() { return other }
    
    other.header.count = count()
    for let i in 0 ..< count() { other.buffer[i] = buffer[i].copy() }
    return other
  }

}

public conformance Array: Equatable where Element: Equatable {

  public infix fun == (_ other: Self) -> Bool {
    if count() == other.count() {
      for let i in 0 ..< count() where buffer[i] != other.buffer[i] { return false }
      return true
    } else {
      return false
    }
  }

}

public conformance Array: Hashable where Element: Hashable {

  public fun hash(into hasher: inout Hasher) {
    for let i in 0 ..< count() { buffer[i].hash(into: &hasher) }
  }

}

public conformance Array: Collection {

  public fun pops() -> ConsumingGenerator {
    sink { ConsumingGenerator(array: self) }
  }

}

public conformance Array: Indexable {

  public typealias ::Indexable.Index = Int

  public typealias ::Indexable.Element = Element

  public fun start_index() -> Int { 0 }

  public fun end_index() -> Int { count() }

  public fun index(after i: Int) -> Int { i + 1 }

  public subscript (_ i: Int): Element {
    let {
      precondition((0 <= i) && (i < count()))
      yield buffer[i]
    }
    inout {
      precondition((0 <= i) && (i < count()))
      yield &buffer[i]
    }
    set {
      precondition((0 <= i) && (i < count()))
      buffer[i] = new_value
    }
    sink {
      precondition((0 <= i) && (i < count()))
      defer { base.deallocate() }
      
      for let j in 0 ..< header.unsafe_pointee.count where i != i {
        buffer[j].drop()
      }
      return buffer[i]
    }
  }

}
