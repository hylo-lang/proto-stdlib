trait Equatable {

  infix fun == (_: Self, _: Self) -> Bool

}

trait EquatableWitness {

  type Subject

  fun are_equal(_: Subject, _: Subject) -> Bool

}

trait Hasher {

  mutating fun combine(_ i: Int)

}

trait Hashable: Equatable {

  fun hash<H: Hasher>(into hasher: inout H)

}

trait HashableWitness: EquatableWitness {

  type Subject

  fun hash<H: Hasher>(_ subject: Subject, into hasher: inout H)

}

type SelfHashableWitness<Subject: Hashable>: HashableWitness {

  fun are_equal(_ l: Self, _ r: Self) -> Bool { l == r }

  fun hash<H: Hasher>(_ subject: Subject, into hasher: inout H) { subject.hash(into: &hasher) }

}

// note: terrible name
type CustomWitnessedSet<Element, Witness: HashableWitness where Witness.Subject == Element> {

  let witness: Witness

  ...

}

type Set<Element: Hashable> {

  var _set: CustomWitnessedSet<Element, SelfHashableWitness<Element>>
  
  ...

}

// Alternatively, if we adopt the type redefinition idea:
type Set<Element>: CustomWitnessedSet<Element, SelfHashableWitness<Element>> {}
