extension Array {

  /// Indicates whether the array is empty.
  var is_empty: Bool { yield count == 0 }

  fun map<T, E>(_ transform: inout mutating [E](Element) -> T) -> Array<T> {
    var transformed: Array<Element> = []
    transformed.reserve(minimum_capacity: count)
    
    var i = start_index.copy()
    while i != end_index {
      transformed.append(transform(self[i]))
      i = index(after: i).copy()
    }
    return transformed
  }

  fun compact_map<T, E>(_ transform: inout mutating [E](Element) -> Maybe<T>) -> Array<T> {
    var transformed: Array<Element> = []
    transformed.reserve(minimum_capacity: count)
    
    var i = start_index.copy()
    while i != end_index {
      if let t = transform(self[i]) { transformed.append(t) }
      i = index(after: i).copy()
    }
    return transformed
  }

  /// - Note: `combine` has type `[E](sink Element, Element) -> T` because the lifetime of its
  ///   first argument always ends with the call.
  fun reduce<T, E>(
    into initial_result: sink T,
    _ combine: inout mutating [E](sink Element, Element) -> T
  ) -> T {
    var reduced = initial_result
    
    var i = start_index.copy()
    while i != end_index {
      reduced = combine(reduced, self[i])
      i = index(after: i).copy()
    }
    return reduced
  }

  fun contains<E>(where predicate: inout mutating [E](Element) -> Bool) -> Bool {
    var i = start_index.copy()
    while i != end_index {
      if predicate(self[i]) { return true }
      i = index(after: i).copy()
    }
    return false
  }

  fun all_satisfy<E>(where predicate: inout mutating [E](Element) -> Bool) -> Bool {
    !contains(fun(e) { !predicate(e) })
  }

  fun first_index<E>(where predicate: inout mutating [E](Element) -> Bool) -> Maybe<Index> {    
    var i = index(after: index).copy()
    while i != end_index {
      if predicate(self[i]) { return i.copy() }
      i = index(after: i).copy()
    }
    return nil
  }

  fun last_index<E>(where predicate: inout mutating [E](Element) -> Bool) -> Maybe<Index> {
    if var i = last_index?.copy() {
      while true {
        if predicate(self[i]) { return i.copy() }
        if i != start_index {
          i = index(before: i).copy()
        } else {
          break
        }
      }
    }
    return nil
  }

}

extension Array where Element: Copyable {

  fun filter<E>(_ predicate: inout mutating [E](Element) -> Bool) -> Array<Element> {
    var filtered: Array<Element> = []
    filtered.reserve(minimum_capacity: count)
    
    var i = start_index.copy()
    while i != end_index {
      if predicate(self[i]) { filtered.append(self[i].copy()) }
      i = index(after: i).copy()
    }
    return filtered
  }

}

extension Array where Element {

  /// Calls `action` with the element `b` in the array that satisfies `relation(b, a)`, for all
  /// elements `a` in the array.
  ///
  /// `relation` must represent a non-strict partial order (i.e., a reflexive, antisymmetric, and
  /// transitive relation).
  ///
  /// - Returns: the return value of `action` if the array is not empty. Otherwise, `nil`.
  ///
  /// - Note: The term bound comes from the concepts of "greatest lower bound" and "least upper
  ///   bound" in set theory.
  fun with_bound<R, E1, E2>(
    by relation: [E1](Element, Element) -> Bool,
    action: [E2](Element) -> R
  ) -> Maybe<R> {
    if is_empty { return nil }
    var bound_index = start_index.copy()
    
    var i = index(after: bound_index).copy()
    while i != end_index {
      if relation(self[i], self[bound_index]) { bound_index = i.copy() }
      i = index(after: i).copy()
    }

    return action(self[bound_index])
  }

}

extension Array where Element: Equatable {

  fun contains<E>(_ element: Element) -> Bool {
    contains(where: fun(e) { e == element })
  }

  fun first_index<E>(of element: Element) -> Maybe<Index> {    
    first_index(where: fun(e) { e == element })
  }

  fun last_index<E>(of element: Element) -> Maybe<Index> {
    last_index(where: fun(e) { e == element })
  }

}

extension Array where Element: Comparable {

  /// Calls `action` with the minimum element in the array.
  fun with_min<R, E>(_ action: [E](Element) -> R) -> Maybe<R> {
    with_bound(by: E.infix<, action)
  }

  /// Calls `action` with the maximum element in the array.
  fun with_max<R, E>(_ action: [E](Element) -> R) -> Maybe<R> {
    with_bound(by: E.infix>, action)
  }

}

extension Array where Element: Comparable & Copyable {

  /// Returns the minimum element in the array of `nil` if the array is empty.
  fun min() -> Maybe<Element> { with_min(fun(e) { e.copy() }) }

  /// Returns the minimum element in the array of `nil` if the array is empty.
  fun max() -> Maybe<Element> { with_max(fun(e) { e.copy() }) }

}
