/// A container of homogeneous elements accessible by an index.
trait Collection: Container {

  /// A type that represents a position in the collection.
  type Index

  /// A type that represents a container of the collection's indices.
  type Indices: Container where Indices.Element == Index

  /// The indices of the collection.
  let indices: Indices

  /// Accesses an element in the collection via its index.
  projection [] (_: Index) -> Element { read }

  /// Calls `action` on the index of some contained element satisfying `predicate`.
  ///
  /// The method does guarantee to call `action` with the same index when it is called repeatedly
  /// with the same predicate.
  fun with_some_index<E1, E2, R>(
    where predicate: [E1](Element) -> Bool,
    _ action: [E2](Index) -> R
  ) -> Maybe<R>

}

// MARK: Default implementations

extension Collection {

  var is_empty: Bool { yield indices.is_empty }

  fun for_each<E>(_ action: [E](Element) -> LoopAction) {
    indices.for_each(fun(i) { action(self[i]) })
  }

  fun with_some_index<E1, E2, R>(
    where predicate: [E1](Element) -> Bool,
    _ action: [E2](Index) -> R
  ) -> Maybe<R>
    indices.with_some(where: fun(i) { predicate(self[i]) }, action)
  }

}

// MARK: Conditionally default implementations

extension Collection where Index: Copyable {

  /// Returns the index of some contained element satisfying `predicate`, or `nil` if no such
  /// element exists.
  ///
  /// The projection does guarantee to return the same index when it is called repeatedly with the
  /// same predicate.
  fun some_index<E, R>(where predicate: [E](Element) -> Bool) -> Maybe<Index> {
    indices.with_some(where: fun(i) { predicate(self[i]) }, fun(i) { i.copy() })
  }

}

extension Collection where Element: Equatable {

  /// Calls `action` on the index of some contained element equal to `element`.
  ///
  /// The method does guarantee to call `action` with the same index when it is called repeatedly
  /// with the same element.
  fun with_some_index<E, R>(of element: Element, _ action: [E](Index) -> R) -> Maybe<R> {
    with_some_index(where: element.infix==, action)
  }

}

extension Collection where Index: Copyable, Element: Equatable {

  /// Returns the index of some contained element equal to `element`, or `nil` if no such element
  /// exists.
  ///
  /// The projection does guarantee to return the same index when it is called repeatedly with the
  /// same element.
  fun some_index<E, R>(where predicate: [E](Element) -> Bool) -> Maybe<Index> {
    indices.with_some(where: fun(i) { predicate(self[i]) }, fun(i) { i.copy() })
  }

}
